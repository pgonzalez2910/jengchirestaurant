<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kitchen Workforce Management - Schedule vs Actual Tracker</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root {
  --primary: #3182ce;
  --primary-dark: #2c5282;
  --success: #38a169;
  --danger: #e53e3e;
  --warning: #d69e2e;
  --bg: #f7fafc;
  --card: #ffffff;
  --text: #2d3748;
  --muted: #718096;
  --border: #e2e8f0;
  --shadow: 0 4px 12px rgba(0,0,0,0.08);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  padding: 24px;
}
.container { max-width: 1200px; margin: 0 auto; }
header {
  background: var(--card);
  padding: 24px;
  border-radius: 12px;
  box-shadow: var(--shadow);
  margin-bottom: 24px;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
h1 { font-size: 26px; color: var(--primary-dark); font-weight: 800; }
.header-subtitle { color: var(--muted); font-size: 14px; margin-top: 6px; }
.tabs {
  display: flex;
  gap: 12px;
  margin-bottom: 24px;
  flex-wrap: wrap;
}
.tab-btn {
  background: var(--card);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 10px 14px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: 600;
  transition: 0.2s;
}
.tab-btn.active {
  background: var(--primary);
  color: white;
  border-color: var(--primary);
}
.tab-btn:hover { transform: translateY(-1px); }
.tab-content {
  display: none;
  background: var(--card);
  padding: 26px;
  border-radius: 12px;
  box-shadow: var(--shadow);
}
.tab-content.active { display: block; }
.section-title { font-size: 20px; font-weight: 800; margin-bottom: 8px; }
.section-subtitle { color: var(--muted); margin-bottom: 18px; font-size: 14px; }

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 18px;
  margin-bottom: 16px;
}
.form-group { margin-bottom: 14px; }
label { display: block; font-weight: 700; margin-bottom: 6px; font-size: 13px; color: var(--text); }
input, select {
  width: 100%;
  padding: 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  outline: none;
  font-size: 14px;
  background: white;
}
input:focus, select:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(49,130,206,0.15); }
button {
  width: 100%;
  padding: 12px 14px;
  border-radius: 10px;
  border: none;
  font-weight: 800;
  cursor: pointer;
  background: var(--primary);
  color: white;
  transition: 0.2s;
}
button:hover { background: var(--primary-dark); }
button.secondary { background: #edf2f7; color: var(--text); border: 1px solid var(--border); }
button.secondary:hover { background: #e2e8f0; }
button.success { background: var(--success); }
button.success:hover { filter: brightness(0.95); }
button.danger { background: var(--danger); }
button.danger:hover { filter: brightness(0.95); }
button:disabled { opacity: 0.6; cursor: not-allowed; }
.action-bar { display: flex; gap: 12px; margin-top: 10px; flex-wrap: wrap; }
.schedule-table { width: 100%; border-collapse: collapse; }
.schedule-table th, .schedule-table td {
  padding: 10px;
  border-bottom: 1px solid var(--border);
  text-align: left;
  font-size: 13px;
}
.schedule-table th { color: var(--muted); font-weight: 800; }
.badge {
  display: inline-block;
  padding: 4px 8px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  border: 1px solid var(--border);
}
.badge.success { background: rgba(56,161,105,0.12); color: #276749; border-color: rgba(56,161,105,0.35); }
.badge.danger { background: rgba(229,62,62,0.10); color: #9b2c2c; border-color: rgba(229,62,62,0.35); }
.badge.warning { background: rgba(214,158,46,0.12); color: #975a16; border-color: rgba(214,158,46,0.35); }

.stats-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 14px;
  margin-top: 12px;
}
.stat-card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px;
}
.stat-card h3 { font-size: 13px; color: var(--muted); margin-bottom: 8px; font-weight: 800; }
.stat-card .value { font-size: 22px; font-weight: 900; color: var(--text); }
.stat-card .subtext { color: var(--muted); font-size: 12px; margin-top: 4px; }

.chart-container { position: relative; width: 100%; height: 320px; }
.current-period-display { margin-top: 10px; color: var(--muted); font-size: 13px; }
.gap-alert {
  background: #fff3cd;
  color: #856404;
  padding: 12px;
  border-radius: 6px;
  margin-top: 12px;
  font-size: 14px;
  border: 1px solid #ffc107;
}
.employee-row {
  background: #f8fafc;
  padding: 16px;
  border-radius: 8px;
  margin-bottom: 16px;
  border: 1px solid #e2e8f0;
}
.employee-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}
.employee-name { font-weight: 900; color: #2d3748; font-size: 16px; }
.employee-role { color: #718096; font-size: 13px; }
.time-entry { display: flex; gap: 12px; align-items: center; margin-bottom: 8px; }
.time-entry input { flex: 1; }
.hidden { display: none; }

.period-selector {
  background: #f8fafc;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 14px;
  margin-bottom: 14px;
}
.period-controls { display: flex; gap: 14px; align-items: flex-end; flex-wrap: wrap; }

@media (max-width: 768px) {
  .tabs { flex-direction: column; }
  .tab-content { padding: 20px; }
  .stats-grid { grid-template-columns: 1fr; }
  .period-controls { flex-direction: column; }
  .period-controls .form-group { width: 100%; }
  .schedule-table { font-size: 12px; }
  .schedule-table th, .schedule-table td { padding: 8px; }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <div>
      <h1>Kitchen Workforce Management</h1>
      <div class="header-subtitle">Schedule vs Actual Hours Tracking with Break & Gap Analysis</div>
    </div>
  </header>

  <div class="tabs">
    <button class="tab-btn active" onclick="switchTab('schedule')">üìÖ Manage Schedule</button>
    <button class="tab-btn" onclick="switchTab('tasks')">‚è± Task Logging</button>
    <button class="tab-btn" onclick="switchTab('batch')">üìù Batch Entry</button>
    <button class="tab-btn" onclick="switchTab('analytics')">üìä Analytics Dashboard</button>
    <button class="tab-btn" onclick="switchTab('comparison')">üìà Schedule vs Actual</button>
    <button class="tab-btn" onclick="switchTab('gaps')">‚ö†Ô∏è Gap Analysis</button>
  </div>

  <!-- SCHEDULE MANAGEMENT TAB -->
  <div id="schedule" class="tab-content active">
    <h2 class="section-title">Manage Employee Schedule</h2>
    <p class="section-subtitle">Add and edit scheduled shifts for employees</p>

    <div class="card">
      <div class="form-group">
        <label for="scheduleDate">üìÖ Date</label>
        <input type="date" id="scheduleDate" required>
      </div>
      <div class="form-group">
        <label for="scheduleEmployee">üë§ Employee</label>
        <select id="scheduleEmployee" required>
          <option value="">-- Select Employee --</option>
          <option value="Julio Mejia">Julio Mejia</option>
          <option value="Leydi Diaz">Leydi Diaz</option>
          <option value="Procoro Tinoco">Procoro Tinoco</option>
          <option value="Wilson Sanchez">Wilson Sanchez</option>
        </select>
      </div>
      <div class="form-group">
        <label for="scheduleRole">üè∑ Role/Position</label>
        <select id="scheduleRole" required>
          <option value="Kitchen Prep">Kitchen Prep</option>
          <option value="Line Cook">Line Cook</option>
          <option value="Fryer">Fryer</option>
          <option value="Dishwasher">Dishwasher</option>
          <option value="Server">Server</option>
        </select>
      </div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
        <div class="form-group">
          <label for="scheduleStart">‚è∞ Scheduled Start Time</label>
          <input type="time" id="scheduleStart" required>
        </div>
        <div class="form-group">
          <label for="scheduleEnd">‚è∞ Scheduled End Time</label>
          <input type="time" id="scheduleEnd" required>
        </div>
      </div>
      <div class="action-bar">
        <button onclick="addSchedule()" class="success">üíæ Add Schedule</button>
        <button onclick="loadSchedules()" class="secondary">üîÑ Refresh</button>
      </div>
      <div id="scheduleStatus" class="hidden" style="margin-top: 16px;"></div>
    </div>

    <div class="card">
      <h3 style="margin-bottom: 16px; font-size: 16px; color: #2d3748;">üìã Scheduled Shifts</h3>
      <div id="scheduleList">
        <p style="color: #718096; text-align: center; padding: 24px;">Loading schedules.</p>
      </div>
    </div>
  </div>

  <!-- TASK LOGGING TAB -->
  <div id="tasks" class="tab-content">
    <h2 class="section-title">Real-Time Task Logging</h2>
    <p class="section-subtitle">Track actual work hours with automatic break deduction</p>

    <div class="card">
      <div class="form-group">
        <label for="taskEmployee">üë§ Employee</label>
        <select id="taskEmployee" required>
          <option value="">-- Select Employee --</option>
          <option value="Julio Mejia">Julio Mejia</option>
          <option value="Leydi Diaz">Leydi Diaz</option>
          <option value="Procoro Tinoco">Procoro Tinoco</option>
          <option value="Wilson Sanchez">Wilson Sanchez</option>
        </select>
      </div>
      <div class="form-group">
        <label for="taskDate">üìÖ Date</label>
        <input type="date" id="taskDate" required>
      </div>
      <div class="form-group">
        <label for="taskRole">üè∑ Role</label>
        <select id="taskRole" required>
          <option value="Kitchen Prep">Kitchen Prep</option>
          <option value="Line Cook">Line Cook</option>
          <option value="Fryer">Fryer</option>
          <option value="Dishwasher">Dishwasher</option>
        </select>
      </div>
      <div class="form-group">
        <label for="taskName">üìù Task Name</label>
        <input type="text" id="taskName" placeholder="Type task name..." required>
      </div>
      <div class="action-bar">
        <button onclick="startTask()" id="startBtn">‚ñ∂ Start Task</button>
        <button onclick="stopTask()" id="stopBtn" disabled class="danger">‚èπ Stop Task</button>
      </div>
      <div id="taskStatus" class="hidden" style="margin-top: 16px;"></div>
      <div id="activeTaskInfo" class="hidden" style="margin-top: 20px; padding: 16px; background: #f0f9ff; border-radius: 6px; border: 1px solid #bee3f8;">
        <h4 style="color: #2c5282; margin-bottom: 8px;">Active Task</h4>
        <p id="activeTaskDisplay" style="font-weight: 600; margin-bottom: 8px;"></p>
        <p id="taskTimer" style="font-size: 14px; color: #4a5568;"></p>
        <div style="display: flex; gap: 12px; margin-top: 12px; flex-wrap: wrap;">
          <button onclick="updateActiveTask()" class="secondary" style="width: auto;">‚úèÔ∏è Update Task</button>
          <button onclick="deleteActiveTask()" class="danger" style="width: auto;">üóë Delete Task</button>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h3 style="margin-bottom: 12px; font-size: 16px; color: #2d3748;">üßæ Tasks for Selected Day</h3>
      <p style="color: #718096; margin-bottom: 12px; font-size: 13px;">Shows all task logs for the selected employee/date. You can update or delete any entry. Open tasks can be restored after refresh.</p>
      <div class="action-bar" style="justify-content: flex-start;">
        <button onclick="loadTasksForDay()" class="secondary" style="width: auto;">üîÑ Refresh List</button>
        <button onclick="restoreOpenTask()" style="width: auto;">üß† Restore Open Task</button>
      </div>
      <div id="taskDayList">
        <p style="color: #718096; text-align: center; padding: 24px;">Select an employee and date to load tasks.</p>
      </div>
    </div>
  </div>

  <!-- BATCH ENTRY TAB -->
  <div id="batch" class="tab-content">
    <h2 class="section-title">Batch Entry</h2>
    <p class="section-subtitle">Enter multiple employees' time logs at once</p>

    <div class="card">
      <div class="form-group">
        <label for="batchDate">üìÖ Date</label>
        <input type="date" id="batchDate" required>
      </div>

      <div id="batchRows"></div>

      <div class="action-bar">
        <button onclick="addBatchRow()" class="secondary" style="width: auto;">‚ûï Add Employee</button>
        <button onclick="saveBatch()" class="success" style="width: auto;">üíæ Save Batch</button>
      </div>

      <div id="batchStatus" class="hidden" style="margin-top: 16px;"></div>
    </div>
  </div>

  <!-- ANALYTICS TAB -->
  <div id="analytics" class="tab-content">
    <h2 class="section-title">Analytics Dashboard</h2>
    <p class="section-subtitle">Overview of scheduled vs worked hours with gap analysis</p>

    <div class="period-selector">
      <h4>üìÖ Select Period</h4>
      <div class="period-controls">
        <div class="form-group">
          <label for="analyticsPeriod">Period</label>
          <select id="analyticsPeriod" onchange="changeAnalyticsPeriod()">
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly">Monthly</option>
            <option value="custom">Custom Range</option>
          </select>
        </div>

        <div class="form-group" id="analyticsDailyGroup">
          <label for="analyticsDate">Date</label>
          <input type="date" id="analyticsDate">
        </div>

        <div class="form-group" id="analyticsWeeklyGroup" style="display: none;">
          <label for="analyticsWeek">Week Starting</label>
          <input type="date" id="analyticsWeek">
        </div>

        <div class="form-group" id="analyticsMonthlyGroup" style="display: none;">
          <label for="analyticsMonth">Month</label>
          <input type="month" id="analyticsMonth">
        </div>

        <div class="form-group" id="analyticsCustomGroup" style="display: none;">
          <label for="analyticsStart">Start Date</label>
          <input type="date" id="analyticsStart">
        </div>
        <div class="form-group" id="analyticsCustomGroup2" style="display: none;">
          <label for="analyticsEnd">End Date</label>
          <input type="date" id="analyticsEnd">
        </div>

        <button onclick="loadAnalytics()" style="width: auto; margin-bottom: 0;">üìä Load Analytics</button>
      </div>
      <div id="currentPeriodDisplay" class="current-period-display">Loading.</div>
    </div>

    <div class="stats-grid">
      <div class="stat-card">
        <h3>Total Scheduled Hours</h3>
        <div class="value" id="totalScheduled">-</div>
        <div class="subtext">Across all employees</div>
      </div>
      <div class="stat-card">
        <h3>Total Worked Hours</h3>
        <div class="value" id="totalWorked">-</div>
        <div class="subtext">Actual time logged</div>
      </div>
      <div class="stat-card">
        <h3>Total Break Time</h3>
        <div class="value" id="totalBreak">-</div>
        <div class="subtext">1 hour per employee</div>
      </div>
      <div class="stat-card">
        <h3>Variance</h3>
        <div class="value" id="totalVariance">-</div>
        <div class="subtext">Scheduled vs Worked</div>
      </div>
      <div class="stat-card">
        <h3>Total Gap Time</h3>
        <div class="value" id="totalGap">-</div>
        <div class="subtext">Between tasks (within scheduled hours)</div>
      </div>
      <div class="stat-card">
        <h3>Efficiency Rate</h3>
        <div class="value" id="efficiencyRate">-</div>
        <div class="subtext">Productivity %</div>
      </div>
    </div>

    <div class="card" style="margin-top: 24px;">
      <h3 style="margin-bottom: 16px;">üìä Hours Distribution</h3>
      <div class="chart-container">
        <canvas id="hoursChart"></canvas>
      </div>
    </div>

    <div class="card" style="margin-top: 24px;">
      <h3 style="margin-bottom: 16px;">üë• Employee Breakdown</h3>
      <div id="employeeBreakdown">
        <p style="color: #718096; text-align: center; padding: 24px;">Loading.</p>
      </div>
    </div>
  </div>

  <!-- SCHEDULE VS ACTUAL COMPARISON TAB -->
  <div id="comparison" class="tab-content">
    <h2 class="section-title">Schedule vs Actual Comparison</h2>
    <p class="section-subtitle">Detailed comparison of scheduled hours vs actual worked hours</p>

    <div class="period-selector">
      <h4>üìÖ Select Period</h4>
      <div class="period-controls">
        <div class="form-group">
          <label for="comparePeriod">Period</label>
          <select id="comparePeriod" onchange="changeComparePeriod()">
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly">Monthly</option>
            <option value="custom">Custom Range</option>
          </select>
        </div>
        <div class="form-group" id="compareDailyGroup">
          <label for="compareDate">Date</label>
          <input type="date" id="compareDate">
        </div>
        <div class="form-group" id="compareWeeklyGroup" style="display: none;">
          <label for="compareWeek">Week Starting</label>
          <input type="date" id="compareWeek">
        </div>
        <div class="form-group" id="compareMonthlyGroup" style="display: none;">
          <label for="compareMonth">Month</label>
          <input type="month" id="compareMonth">
        </div>
        <div class="form-group" id="compareCustomGroup" style="display: none;">
          <label for="compareStart">Start Date</label>
          <input type="date" id="compareStart">
        </div>
        <div class="form-group" id="compareCustomGroup2" style="display: none;">
          <label for="compareEnd">End Date</label>
          <input type="date" id="compareEnd">
        </div>
        <button onclick="loadComparison()" style="width: auto; margin-bottom: 0;">üìà Load Comparison</button>
      </div>
    </div>

    <div class="card">
      <div id="comparisonList">
        <p style="color: #718096; text-align: center; padding: 24px;">Load a period to view results.</p>
      </div>
    </div>
  </div>

  <!-- GAP ANALYSIS TAB -->
  <div id="gaps" class="tab-content">
    <h2 class="section-title">Gap Analysis</h2>
    <p class="section-subtitle">Find idle time gaps between tasks (within scheduled hours only)</p>

    <div class="period-selector">
      <h4>üìÖ Select Period</h4>
      <div class="period-controls">
        <div class="form-group">
          <label for="gapPeriod">Period</label>
          <select id="gapPeriod" onchange="changeGapPeriod()">
            <option value="daily">Daily</option>
            <option value="weekly">Weekly</option>
            <option value="monthly">Monthly</option>
            <option value="custom">Custom Range</option>
          </select>
        </div>

        <div class="form-group" id="gapDailyGroup">
          <label for="gapDate">Date</label>
          <input type="date" id="gapDate">
        </div>

        <div class="form-group" id="gapWeeklyGroup" style="display: none;">
          <label for="gapWeek">Week Starting</label>
          <input type="date" id="gapWeek">
        </div>

        <div class="form-group" id="gapMonthlyGroup" style="display: none;">
          <label for="gapMonth">Month</label>
          <input type="month" id="gapMonth">
        </div>

        <div class="form-group" id="gapCustomGroup" style="display: none;">
          <label for="gapStart">Start Date</label>
          <input type="date" id="gapStart">
        </div>
        <div class="form-group" id="gapCustomGroup2" style="display: none;">
          <label for="gapEnd">End Date</label>
          <input type="date" id="gapEnd">
        </div>

        <button onclick="loadGapAnalysis()" style="width: auto; margin-bottom: 0;">‚ö†Ô∏è Load Gap Analysis</button>
      </div>
    </div>

    <div class="card">
      <div id="gapList">
        <p style="color: #718096; text-align: center; padding: 24px;">Load a period to view gaps.</p>
      </div>
    </div>
  </div>

</div>

<script>
const SUPABASE_URL = "https://kpldzwlftkvjjntgsqxx.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtwbGR6d2xmdGt2ampudGdzcXh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY2MzE5NzAsImV4cCI6MjA2MjIwNzk3MH0.qnWbOQv2RLPsIyO-oRwQkAN2VhmmdhTBt46SweUsLbs";
const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let activeTaskId = null;
let activeTaskInterval = null;
let activeTaskStartTime = null;
let batchRowCount = 0;

// Initialize
window.onload = function() {
  const today = new Date().toISOString().split('T')[0];
  document.getElementById('scheduleDate').value = today;
  document.getElementById('analyticsDate').value = today;
  document.getElementById('compareDate').value = today;
  document.getElementById('gapDate').value = today;
  document.getElementById('batchDate').value = today;
  document.getElementById('taskDate').value = today;

  // Task logging: auto-load daily tasks + restore any open task
  document.getElementById('taskEmployee').addEventListener('change', () => { loadTasksForDay(); restoreOpenTask(); });
  document.getElementById('taskDate').addEventListener('change', () => { loadTasksForDay(); restoreOpenTask(); });

  document.getElementById('analyticsWeek').value = getWeekStart(new Date()).toISOString().split('T')[0];
  document.getElementById('compareWeek').value = getWeekStart(new Date()).toISOString().split('T')[0];
  document.getElementById('gapWeek').value = getWeekStart(new Date()).toISOString().split('T')[0];
  document.getElementById('analyticsMonth').value = `${new Date().getFullYear()}-${String(new Date().getMonth()+1).padStart(2,'0')}`;
  document.getElementById('compareMonth').value = `${new Date().getFullYear()}-${String(new Date().getMonth()+1).padStart(2,'0')}`;
  document.getElementById('gapMonth').value = `${new Date().getFullYear()}-${String(new Date().getMonth()+1).padStart(2,'0')}`;

  loadSchedules();
};

// ========== UTILS ==========
function switchTab(tabName) {
  document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  document.getElementById(tabName).classList.add('active');

  // Support inline onclick without passing event
  const ev = window.event;
  if (ev?.target) ev.target.classList.add('active');

  // Task tab helpers
  if (tabName === 'tasks') {
    loadTasksForDay();
    restoreOpenTask();
  }
}

function getWeekStart(date) {
  const d = new Date(date);
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  return new Date(d.setDate(diff));
}

function getMonthStart(date) {
  return new Date(date.getFullYear(), date.getMonth(), 1);
}

function formatDate(dateStr) {
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function formatTime(minutes) {
  const sign = minutes < 0 ? '-' : '';
  const abs = Math.abs(minutes);
  const h = Math.floor(abs / 60);
  const m = Math.round(abs % 60);
  const body = h > 0 ? `${h}h ${m}m` : `${m}m`;
  return sign + body;
}

function calculateHours(start, end) {
  const s = new Date(`2000-01-01T${start}`);
  const e = new Date(`2000-01-01T${end}`);
  return (e - s) / (1000 * 60); // minutes
}

async function getEmployeeIdByName(employeeName) {
  // Get employee id, create if missing
  const { data, error } = await supabaseClient
    .from('kitchen_prep_employees')
    .select('id')
    .eq('name', employeeName)
    .maybeSingle();

  if (!error && data?.id) return data.id;

  // Create if not found
  const { data: created, error: createError } = await supabaseClient
    .from('kitchen_prep_employees')
    .insert({ name: employeeName })
    .select('id')
    .single();

  if (createError) throw createError;
  return created.id;
}

async function getOrCreateTaskIdByName(taskName) {
  const { data: task, error } = await supabaseClient
    .from('kitchen_tasks')
    .select('id')
    .eq('name', taskName)
    .maybeSingle();

  if (!error && task?.id) return task.id;

  const { data: newTask, error: insertError } = await supabaseClient
    .from('kitchen_tasks')
    .insert({ name: taskName, description: taskName })
    .select()
    .single();

  if (insertError) throw insertError;
  return newTask.id;
}

// ========== SCHEDULE MANAGEMENT ==========
async function addSchedule() {
  const date = document.getElementById('scheduleDate').value;
  const employee = document.getElementById('scheduleEmployee').value;
  const role = document.getElementById('scheduleRole').value;
  const startTime = document.getElementById('scheduleStart').value;
  const endTime = document.getElementById('scheduleEnd').value;

  if (!date || !employee || !startTime || !endTime) {
    showScheduleStatus('Please fill all fields!', 'error');
    return;
  }

  if (startTime >= endTime) {
    showScheduleStatus('End time must be after start time!', 'error');
    return;
  }

  try {
    // Ensure employee exists
    await getEmployeeIdByName(employee);

    // Add schedule
    const { error } = await supabaseClient
      .from('employee_schedules')
      .insert({
        employee_name: employee,
        role: role,
        schedule_date: date,
        start_time: startTime,
        end_time: endTime,
        break_minutes: 60
      });

    if (error) throw error;

    showScheduleStatus('Schedule added successfully!', 'success');
    loadSchedules();
  } catch (error) {
    console.error('Error adding schedule:', error);
    showScheduleStatus('Error adding schedule', 'error');
  }
}

async function loadSchedules() {
  try {
    const { data: schedules, error } = await supabaseClient
      .from('employee_schedules')
      .select('*')
      .order('schedule_date', { ascending: false })
      .limit(50);

    if (error) throw error;

    const container = document.getElementById('scheduleList');
    if (!schedules || schedules.length === 0) {
      container.innerHTML = '<p style="color: #718096; text-align: center; padding: 24px;">No schedules found</p>';
      return;
    }

    let html = '<table class="schedule-table"><thead><tr><th>Date</th><th>Employee</th><th>Role</th><th>Scheduled</th><th>Duration</th><th>Break</th><th>Actions</th></tr></thead><tbody>';

    schedules.forEach(schedule => {
      const minutes = calculateHours(schedule.start_time, schedule.end_time);
      html += `
        <tr>
          <td>${formatDate(schedule.schedule_date)}</td>
          <td><strong>${schedule.employee_name}</strong></td>
          <td>${schedule.role || ''}</td>
          <td>${schedule.start_time} - ${schedule.end_time}</td>
          <td>${formatTime(minutes)}</td>
          <td>${formatTime(schedule.break_minutes || 60)}</td>
          <td>
            <button class="danger" style="width:auto; padding:8px 10px; font-size:12px;" onclick="deleteSchedule('${schedule.id}')">Delete</button>
          </td>
        </tr>
      `;
    });

    html += '</tbody></table>';
    container.innerHTML = html;
  } catch (error) {
    console.error('Error loading schedules:', error);
  }
}

async function deleteSchedule(id) {
  const yes = confirm('Delete this schedule?');
  if (!yes) return;

  try {
    await supabaseClient.from('employee_schedules').delete().eq('id', id);
    loadSchedules();
  } catch (error) {
    console.error('Error deleting schedule:', error);
  }
}

function showScheduleStatus(message, type) {
  const div = document.getElementById('scheduleStatus');
  div.textContent = message;
  div.className = type;
  div.classList.remove('hidden');
  setTimeout(() => div.classList.add('hidden'), 3000);
}

// ========== TASK LOGGING ==========
async function startTask() {
  const employee = document.getElementById('taskEmployee').value;
  const role = document.getElementById('taskRole').value;
  const taskName = document.getElementById('taskName').value?.trim();
  const selectedDate = document.getElementById('taskDate').value;

  if (!employee || !taskName || !selectedDate) {
    showTaskStatus('Please select employee, date, and enter a task name', 'error');
    return;
  }

  // Prevent multiple open tasks
  if (activeTaskId) {
    showTaskStatus('There is already an active task. Stop it first (or delete it).', 'error');
    return;
  }

  try {
    // If there is an open task for this employee/date, force restore instead of creating another one
    const existing = await findOpenTask(employee, selectedDate);
    if (existing) {
      hydrateActiveTask(existing);
      showTaskStatus('Open task restored (it was already running).', 'success');
      return;
    }

    const now = new Date();
    const employeeId = await getEmployeeIdByName(employee);
    const taskId = await getOrCreateTaskIdByName(taskName);

    // Create time log (open task)
    const { data: log, error } = await supabaseClient
      .from('task_time_logs')
      .insert({
        employee_id: employeeId,
        task_id: taskId,
        role: role,
        start_time: now.toISOString(),
        date: selectedDate
      })
      .select(`
        *,
        kitchen_prep_employees(name),
        kitchen_tasks(name)
      `)
      .single();

    if (error) throw error;

    hydrateActiveTask(log);

    // Persist so refresh/reopen can restore
    localStorage.setItem('kitchen_active_task_id', log.id);
    localStorage.setItem('kitchen_active_task_employee', employee);
    localStorage.setItem('kitchen_active_task_date', selectedDate);

    showTaskStatus('Task started!', 'success');
    loadTasksForDay();
  } catch (error) {
    console.error('Error starting task:', error);
    showTaskStatus('Error starting task', 'error');
  }
}

async function stopTask() {
  if (!activeTaskId) return;

  try {
    const now = new Date();

    await supabaseClient
      .from('task_time_logs')
      .update({ end_time: now.toISOString() })
      .eq('id', activeTaskId);

    clearInterval(activeTaskInterval);

    // Clear persisted open task
    localStorage.removeItem('kitchen_active_task_id');
    localStorage.removeItem('kitchen_active_task_employee');
    localStorage.removeItem('kitchen_active_task_date');

    activeTaskId = null;
    activeTaskStartTime = null;

    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('activeTaskInfo').classList.add('hidden');
    document.getElementById('taskName').value = '';

    showTaskStatus('Task completed!', 'success');
    loadTasksForDay();
  } catch (error) {
    console.error('Error stopping task:', error);
    showTaskStatus('Error stopping task', 'error');
  }
}

function showTaskStatus(message, type) {
  const div = document.getElementById('taskStatus');
  div.textContent = message;
  div.className = type;
  div.classList.remove('hidden');
  setTimeout(() => div.classList.add('hidden'), 3000);
}

// ========== TASK LOG ADMIN (RESTORE / UPDATE / DELETE) ==========
function toLocalHHMM(isoStr) {
  if (!isoStr) return '';
  const d = new Date(isoStr);
  const hh = String(d.getHours()).padStart(2, '0');
  const mm = String(d.getMinutes()).padStart(2, '0');
  return `${hh}:${mm}`;
}

function buildISOFromDateTime(dateStr, hhmm) {
  if (!dateStr || !hhmm) return null;
  const d = new Date(`${dateStr}T${hhmm}`);
  return d.toISOString();
}

function startActiveTimer() {
  clearInterval(activeTaskInterval);
  const tick = () => {
    if (!activeTaskStartTime) return;
    const diffMs = Date.now() - activeTaskStartTime.getTime();
    const totalMinutes = Math.floor(diffMs / 60000);
    const h = Math.floor(totalMinutes / 60);
    const m = totalMinutes % 60;
    document.getElementById('taskTimer').textContent = `Elapsed: ${h}h ${String(m).padStart(2,'0')}m`;
  };
  tick();
  activeTaskInterval = setInterval(tick, 1000);
}

function hydrateActiveTask(log) {
  activeTaskId = log.id;
  activeTaskStartTime = new Date(log.start_time);

  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;

  const empName = log.kitchen_prep_employees?.name || document.getElementById('taskEmployee').value || 'Employee';
  const taskName = log.kitchen_tasks?.name || 'Task';
  const role = log.role || '';

  document.getElementById('activeTaskDisplay').textContent = `${empName} - ${taskName} (${role})`;
  document.getElementById('activeTaskInfo').classList.remove('hidden');

  startActiveTimer();
}

async function findOpenTask(employeeName, dateStr) {
  if (!employeeName || !dateStr) return null;

  const employeeId = await getEmployeeIdByName(employeeName);

  const { data, error } = await supabaseClient
    .from('task_time_logs')
    .select(`
      *,
      kitchen_prep_employees(name),
      kitchen_tasks(name)
    `)
    .eq('employee_id', employeeId)
    .eq('date', dateStr)
    .is('end_time', null)
    .order('start_time', { ascending: false })
    .limit(1);

  if (error) throw error;
  return (data && data.length > 0) ? data[0] : null;
}

async function restoreOpenTask() {
  const employee = document.getElementById('taskEmployee').value;
  const selectedDate = document.getElementById('taskDate').value;

  if (!employee || !selectedDate) return;

  if (activeTaskId) return; // already active in UI

  try {
    const storedId = localStorage.getItem('kitchen_active_task_id');
    const storedEmp = localStorage.getItem('kitchen_active_task_employee');
    const storedDate = localStorage.getItem('kitchen_active_task_date');

    // Prefer restoring the exact stored task (prevents grabbing someone else's open task)
    if (storedId && storedEmp === employee && storedDate === selectedDate) {
      const { data, error } = await supabaseClient
        .from('task_time_logs')
        .select(`
          *,
          kitchen_prep_employees(name),
          kitchen_tasks(name)
        `)
        .eq('id', storedId)
        .single();

      // If it still exists and is open, hydrate
      if (!error && data && !data.end_time) {
        hydrateActiveTask(data);
        return;
      }
    }

    // Fallback: query for any open task for this employee/date
    const open = await findOpenTask(employee, selectedDate);
    if (open) {
      hydrateActiveTask(open);
      localStorage.setItem('kitchen_active_task_id', open.id);
      localStorage.setItem('kitchen_active_task_employee', employee);
      localStorage.setItem('kitchen_active_task_date', selectedDate);
    }
  } catch (error) {
    console.error('Error restoring open task:', error);
  }
}

async function loadTasksForDay() {
  const employee = document.getElementById('taskEmployee').value;
  const selectedDate = document.getElementById('taskDate').value;
  const container = document.getElementById('taskDayList');

  if (!employee || !selectedDate) {
    container.innerHTML = '<p style="color: #718096; text-align: center; padding: 24px;">Select an employee and date to load tasks.</p>';
    return;
  }

  try {
    const employeeId = await getEmployeeIdByName(employee);

    const { data: logs, error } = await supabaseClient
      .from('task_time_logs')
      .select(`
        *,
        kitchen_tasks(name)
      `)
      .eq('employee_id', employeeId)
      .eq('date', selectedDate)
      .order('start_time', { ascending: true });

    if (error) throw error;

    if (!logs || logs.length === 0) {
      container.innerHTML = '<p style="color: #718096; text-align: center; padding: 24px;">No tasks found for this day.</p>';
      return;
    }

    let html = '<table class="schedule-table"><thead><tr><th>Start</th><th>End</th><th>Task</th><th>Role</th><th>Status</th><th>Actions</th></tr></thead><tbody>';
    logs.forEach(l => {
      const isOpen = !l.end_time;
      html += `
        <tr>
          <td>${new Date(l.start_time).toLocaleTimeString()}</td>
          <td>${l.end_time ? new Date(l.end_time).toLocaleTimeString() : '<span class="badge warning">OPEN</span>'}</td>
          <td><strong>${l.kitchen_tasks?.name || 'N/A'}</strong></td>
          <td>${l.role || ''}</td>
          <td>${isOpen ? '<span class="badge warning">Open</span>' : '<span class="badge success">Closed</span>'}</td>
          <td>
            <button class="secondary" style="width:auto; padding:8px 10px; font-size:12px;" onclick="editTaskLog('${l.id}')">Edit</button>
            <button class="danger" style="width:auto; padding:8px 10px; font-size:12px;" onclick="deleteTaskLog('${l.id}')">Delete</button>
          </td>
        </tr>
      `;
    });
    html += '</tbody></table>';

    container.innerHTML = html;
  } catch (error) {
    console.error('Error loading tasks for day:', error);
    container.innerHTML = '<p style="color: #e53e3e; text-align: center; padding: 24px;">Error loading tasks.</p>';
  }
}

async function editTaskLog(logId) {
  try {
    const { data: log, error } = await supabaseClient
      .from('task_time_logs')
      .select(`
        *,
        kitchen_prep_employees(name),
        kitchen_tasks(name)
      `)
      .eq('id', logId)
      .single();

    if (error) throw error;

    const selectedDate = document.getElementById('taskDate').value || log.date;

    const currentTaskName = log.kitchen_tasks?.name || '';
    const newTaskName = (prompt('Task name:', currentTaskName) || '').trim() || currentTaskName;

    const newRole = (prompt('Role:', log.role || '') || '').trim() || (log.role || '');

    const startHHMM = prompt('Start time (HH:MM):', toLocalHHMM(log.start_time)) || toLocalHHMM(log.start_time);
    let endHHMM = log.end_time ? (prompt('End time (HH:MM) - leave blank to keep open:', toLocalHHMM(log.end_time)) || toLocalHHMM(log.end_time)) : (prompt('End time (HH:MM) - leave blank to keep open:', '') || '');

    // Normalize blank end for open tasks
    endHHMM = endHHMM.trim();

    const update = {
      role: newRole,
      date: selectedDate,
      start_time: buildISOFromDateTime(selectedDate, startHHMM)
    };

    if (endHHMM) {
      update.end_time = buildISOFromDateTime(selectedDate, endHHMM);
    } else {
      update.end_time = null;
    }

    // Update task id if changed
    if (newTaskName !== currentTaskName) {
      update.task_id = await getOrCreateTaskIdByName(newTaskName);
    }

    await supabaseClient
      .from('task_time_logs')
      .update(update)
      .eq('id', logId);

    // If the edited task is currently active, rehydrate UI
    if (activeTaskId === logId) {
      // Reload the row for accurate joins
      const { data: refreshed } = await supabaseClient
        .from('task_time_logs')
        .select(`
          *,
          kitchen_prep_employees(name),
          kitchen_tasks(name)
        `)
        .eq('id', logId)
        .single();

      if (refreshed && !refreshed.end_time) {
        hydrateActiveTask(refreshed);
      } else {
        // It was closed by edit
        clearInterval(activeTaskInterval);
        activeTaskId = null;
        activeTaskStartTime = null;
        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
        document.getElementById('activeTaskInfo').classList.add('hidden');
        localStorage.removeItem('kitchen_active_task_id');
        localStorage.removeItem('kitchen_active_task_employee');
        localStorage.removeItem('kitchen_active_task_date');
      }
    }

    showTaskStatus('Task updated.', 'success');
    loadTasksForDay();
  } catch (error) {
    console.error('Error editing task log:', error);
    showTaskStatus('Error updating task.', 'error');
  }
}

async function deleteTaskLog(logId) {
  const yes = confirm('Delete this task log? This cannot be undone.');
  if (!yes) return;

  try {
    await supabaseClient
      .from('task_time_logs')
      .delete()
      .eq('id', logId);

    // If deleted task was active, reset UI
    if (activeTaskId === logId) {
      clearInterval(activeTaskInterval);
      activeTaskId = null;
      activeTaskStartTime = null;
      document.getElementById('startBtn').disabled = false;
      document.getElementById('stopBtn').disabled = true;
      document.getElementById('activeTaskInfo').classList.add('hidden');
      localStorage.removeItem('kitchen_active_task_id');
      localStorage.removeItem('kitchen_active_task_employee');
      localStorage.removeItem('kitchen_active_task_date');
    }

    showTaskStatus('Task deleted.', 'success');
    loadTasksForDay();
  } catch (error) {
    console.error('Error deleting task log:', error);
    showTaskStatus('Error deleting task.', 'error');
  }
}

function updateActiveTask() {
  if (!activeTaskId) return;
  editTaskLog(activeTaskId);
}

function deleteActiveTask() {
  if (!activeTaskId) return;
  deleteTaskLog(activeTaskId);
}

// ========== BATCH ENTRY ==========
function addBatchRow() {
  batchRowCount++;
  const container = document.getElementById('batchRows');
  const row = document.createElement('div');
  row.className = 'employee-row';
  row.innerHTML = `
    <div class="employee-header">
      <div>
        <div class="employee-name">Employee #${batchRowCount}</div>
        <div class="employee-role">Add tasks for this employee</div>
      </div>
      <button class="danger" style="width:auto; padding:8px 12px; font-size:12px;" onclick="this.closest('.employee-row').remove()">Remove</button>
    </div>

    <div class="form-group">
      <label>üë§ Employee Name</label>
      <input type="text" class="batch-employee" placeholder="Employee name..." required>
    </div>

    <div class="form-group">
      <label>üè∑ Role</label>
      <select class="batch-role">
        <option value="Kitchen Prep">Kitchen Prep</option>
        <option value="Line Cook">Line Cook</option>
        <option value="Fryer">Fryer</option>
        <option value="Dishwasher">Dishwasher</option>
      </select>
    </div>

    <div class="time-entries"></div>

    <button class="secondary" style="width:auto;" onclick="addTimeEntry(this)">‚ûï Add Task</button>
  `;
  container.appendChild(row);
  addTimeEntry(row.querySelector('button.secondary'));
}

function addTimeEntry(btn) {
  const row = btn.closest('.employee-row');
  const container = row.querySelector('.time-entries');

  const div = document.createElement('div');
  div.className = 'time-entry';
  div.innerHTML = `
    <input type="text" class="batch-task" placeholder="Task name..." required>
    <input type="time" class="batch-start" required>
    <input type="time" class="batch-end" required>
    <button class="danger" style="width:auto; padding:8px 10px; font-size:12px;" onclick="this.parentElement.remove()">‚úñ</button>
  `;
  container.appendChild(div);
}

async function saveBatch() {
  const date = document.getElementById('batchDate').value;
  if (!date) {
    showBatchStatus('Please select a date', 'error');
    return;
  }

  const rows = document.querySelectorAll('.employee-row');
  if (rows.length === 0) {
    showBatchStatus('Add at least one employee row', 'error');
    return;
  }

  try {
    for (const row of rows) {
      const employeeName = row.querySelector('.batch-employee').value.trim();
      const role = row.querySelector('.batch-role').value;
      if (!employeeName) continue;

      const employeeId = await getEmployeeIdByName(employeeName);

      const entries = row.querySelectorAll('.time-entry');
      for (const entry of entries) {
        const taskName = entry.querySelector('.batch-task').value.trim();
        const start = entry.querySelector('.batch-start').value;
        const end = entry.querySelector('.batch-end').value;
        if (!taskName || !start || !end) continue;

        const taskId = await getOrCreateTaskIdByName(taskName);

        const startIso = new Date(`${date}T${start}`).toISOString();
        const endIso = new Date(`${date}T${end}`).toISOString();

        await supabaseClient
          .from('task_time_logs')
          .insert({
            employee_id: employeeId,
            task_id: taskId,
            role: role,
            start_time: startIso,
            end_time: endIso,
            date: date
          });
      }
    }

    showBatchStatus('Batch saved successfully!', 'success');
    document.getElementById('batchRows').innerHTML = '';
    batchRowCount = 0;
  } catch (error) {
    console.error('Error saving batch:', error);
    showBatchStatus('Error saving batch', 'error');
  }
}

function showBatchStatus(message, type) {
  const div = document.getElementById('batchStatus');
  div.textContent = message;
  div.className = type;
  div.classList.remove('hidden');
  setTimeout(() => div.classList.add('hidden'), 3000);
}

// ========== ANALYTICS ==========
function changeAnalyticsPeriod() {
  const period = document.getElementById('analyticsPeriod').value;
  document.getElementById('analyticsDailyGroup').style.display = period === 'daily' ? 'block' : 'none';
  document.getElementById('analyticsWeeklyGroup').style.display = period === 'weekly' ? 'block' : 'none';
  document.getElementById('analyticsMonthlyGroup').style.display = period === 'monthly' ? 'block' : 'none';
  document.getElementById('analyticsCustomGroup').style.display = period === 'custom' ? 'block' : 'none';
  document.getElementById('analyticsCustomGroup2').style.display = period === 'custom' ? 'block' : 'none';
}

let hoursChart = null;

async function loadAnalytics() {
  const period = document.getElementById('analyticsPeriod').value;
  let startDate, endDate, displayText;

  if (period === 'daily') {
    startDate = document.getElementById('analyticsDate').value;
    endDate = startDate;
    displayText = `Daily - ${formatDate(startDate)}`;
  } else if (period === 'weekly') {
    startDate = document.getElementById('analyticsWeek').value;
    const weekEnd = new Date(startDate);
    weekEnd.setDate(weekEnd.getDate() + 6);
    endDate = weekEnd.toISOString().split('T')[0];
    displayText = `Weekly - ${formatDate(startDate)} to ${formatDate(endDate)}`;
  } else if (period === 'monthly') {
    const month = document.getElementById('analyticsMonth').value; // YYYY-MM
    if (!month) return;
    const [y, m] = month.split('-').map(n => parseInt(n, 10));
    startDate = `${month}-01`;
    const lastDay = new Date(y, m, 0).getDate();
    endDate = `${month}-${String(lastDay).padStart(2,'0')}`;
    displayText = `Monthly - ${formatDate(startDate)} to ${formatDate(endDate)}`;
  } else {
    startDate = document.getElementById('analyticsStart').value;
    endDate = document.getElementById('analyticsEnd').value;
    displayText = `Custom - ${formatDate(startDate)} to ${formatDate(endDate)}`;
  }

  document.getElementById('currentPeriodDisplay').textContent = displayText;

  try {
    const { data: schedules } = await supabaseClient
      .from('employee_schedules')
      .select('*')
      .gte('schedule_date', startDate)
      .lte('schedule_date', endDate);

    const { data: logs } = await supabaseClient
      .from('task_time_logs')
      .select(`
        *,
        kitchen_prep_employees(name),
        kitchen_tasks(name)
      `)
      .gte('date', startDate)
      .lte('date', endDate)
      .order('start_time', { ascending: true });

    // Calculate totals
    let totalScheduledMinutes = 0;
    let totalWorkedMinutes = 0;
    let totalBreakMinutes = 0;
    let totalGapMinutes = 0;

    const employeeStats = {};

    // Process schedules
    if (schedules) {
      schedules.forEach(schedule => {
        const minutes = calculateHours(schedule.start_time, schedule.end_time);
        totalScheduledMinutes += minutes;
        totalBreakMinutes += schedule.break_minutes || 60;

        if (!employeeStats[schedule.employee_name]) {
          employeeStats[schedule.employee_name] = {
            scheduled: 0,
            worked: 0,
            break: 0,
            tasks: 0
          };
        }
        employeeStats[schedule.employee_name].scheduled += minutes;
        employeeStats[schedule.employee_name].break += schedule.break_minutes || 60;
      });
    }

    // Process logs (worked minutes + gap minutes)
    // Gap minutes = idle time BETWEEN tasks for the SAME employee on the SAME date,
    // and ONLY the portion that overlaps the employee's scheduled shift (if a schedule exists).
    if (logs) {
      // Build schedule map: employee_name|date -> {start, end}
      const scheduleMap = new Map();
      (schedules || []).forEach(s => {
        scheduleMap.set(`${s.employee_name}|${s.schedule_date}`, { start: s.start_time, end: s.end_time });
      });

      // Group logs by employee|date
      const grouped = {};
      logs.forEach(log => {
        if (!log.end_time) return;

        const emp = log.kitchen_prep_employees?.name;
        if (!emp) return;

        const logDate = log.date || (log.start_time ? log.start_time.split('T')[0] : null);
        if (!logDate) return;

        const worked = (new Date(log.end_time) - new Date(log.start_time)) / (1000 * 60);
        totalWorkedMinutes += worked;

        if (!employeeStats[emp]) {
          employeeStats[emp] = { scheduled: 0, worked: 0, break: 0, tasks: 0 };
        }
        employeeStats[emp].worked += worked;
        employeeStats[emp].tasks++;

        const key = `${emp}|${logDate}`;
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(log);
      });

      // Compute idle/gap minutes within scheduled window (between first and last task only)
      Object.entries(grouped).forEach(([key, arr]) => {
        arr.sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
        const schedule = scheduleMap.get(key);

        // Parse scheduled window (if exists)
        let scheduledStart = null;
        let scheduledEnd = null;
        if (schedule) {
          const [emp, d] = key.split('|');
          scheduledStart = new Date(`${d}T${schedule.start}`);
          scheduledEnd = new Date(`${d}T${schedule.end}`);
        }

        for (let i = 1; i < arr.length; i++) {
          const prevEnd = new Date(arr[i - 1].end_time);
          const nextStart = new Date(arr[i].start_time);
          if (!(nextStart > prevEnd)) continue;

          let gapStart = prevEnd;
          let gapEnd = nextStart;

          // Only count the portion inside the scheduled shift
          if (scheduledStart && scheduledEnd) {
            const effectiveStart = gapStart < scheduledStart ? scheduledStart : gapStart;
            const effectiveEnd = gapEnd > scheduledEnd ? scheduledEnd : gapEnd;
            if (effectiveStart < effectiveEnd) {
              totalGapMinutes += (effectiveEnd - effectiveStart) / (1000 * 60);
            }
          } else {
            // No schedule found: count full gap between tasks
            totalGapMinutes += (gapEnd - gapStart) / (1000 * 60);
          }
        }
      });
    }

    const variance = totalScheduledMinutes - totalWorkedMinutes;
    const efficiency = totalScheduledMinutes > 0 ? Math.max(0, ((totalWorkedMinutes - totalGapMinutes) / totalScheduledMinutes) * 100) : 0;

    document.getElementById('totalScheduled').textContent = formatTime(totalScheduledMinutes);
    document.getElementById('totalWorked').textContent = formatTime(totalWorkedMinutes);
    document.getElementById('totalBreak').textContent = formatTime(totalBreakMinutes);
    document.getElementById('totalVariance').textContent = formatTime(variance);
    document.getElementById('totalGap').textContent = formatTime(totalGapMinutes);
    document.getElementById('efficiencyRate').textContent = `${efficiency.toFixed(1)}%`;

    // Chart
    const ctx = document.getElementById('hoursChart');
    const chartData = {
      labels: ['Scheduled', 'Worked', 'Gap'],
      datasets: [{
        label: 'Minutes',
        data: [totalScheduledMinutes, totalWorkedMinutes, totalGapMinutes]
      }]
    };

    if (hoursChart) hoursChart.destroy();
    hoursChart = new Chart(ctx, {
      type: 'bar',
      data: chartData,
      options: {
        responsive: true,
        maintainAspectRatio: false
      }
    });

    // Employee breakdown
    let html = '';
    Object.keys(employeeStats).sort().forEach(emp => {
      const s = employeeStats[emp];
      const varianceEmp = (s.scheduled || 0) - (s.worked || 0);
      html += `
        <div class="employee-row">
          <div class="employee-header">
            <div>
              <div class="employee-name">${emp}</div>
              <div class="employee-role">${s.tasks || 0} tasks logged</div>
            </div>
            <span class="badge ${varianceEmp >= 0 ? 'warning' : 'danger'}">${formatTime(varianceEmp)}</span>
          </div>
          <div style="display:grid; grid-template-columns: repeat(4,1fr); gap:12px;">
            <div>
              <div style="color:#718096; font-size:12px; font-weight:800;">Scheduled</div>
              <div style="font-weight:900;">${formatTime(s.scheduled || 0)}</div>
            </div>
            <div>
              <div style="color:#718096; font-size:12px; font-weight:800;">Worked</div>
              <div style="font-weight:900;">${formatTime(s.worked || 0)}</div>
            </div>
            <div>
              <div style="color:#718096; font-size:12px; font-weight:800;">Break</div>
              <div style="font-weight:900;">${formatTime(s.break || 0)}</div>
            </div>
            <div>
              <div style="color:#718096; font-size:12px; font-weight:800;">Tasks</div>
              <div style="font-weight:900;">${s.tasks || 0}</div>
            </div>
          </div>
        </div>
      `;
    });

    document.getElementById('employeeBreakdown').innerHTML = html || '<p style="color:#718096; text-align:center; padding:24px;">No employee data.</p>';
  } catch (error) {
    console.error('Error loading analytics:', error);
  }
}

// ========== COMPARISON ==========
function changeComparePeriod() {
  const period = document.getElementById('comparePeriod').value;
  document.getElementById('compareDailyGroup').style.display = period === 'daily' ? 'block' : 'none';
  document.getElementById('compareWeeklyGroup').style.display = period === 'weekly' ? 'block' : 'none';
  document.getElementById('compareMonthlyGroup').style.display = period === 'monthly' ? 'block' : 'none';
  document.getElementById('compareCustomGroup').style.display = period === 'custom' ? 'block' : 'none';
  document.getElementById('compareCustomGroup2').style.display = period === 'custom' ? 'block' : 'none';
}

async function loadComparison() {
  const period = document.getElementById('comparePeriod').value;
  let startDate, endDate;

  if (period === 'daily') {
    startDate = document.getElementById('compareDate').value;
    endDate = startDate;
  } else if (period === 'weekly') {
    startDate = document.getElementById('compareWeek').value;
    const weekEnd = new Date(startDate);
    weekEnd.setDate(weekEnd.getDate() + 6);
    endDate = weekEnd.toISOString().split('T')[0];
  } else if (period === 'monthly') {
    const month = document.getElementById('compareMonth').value; // YYYY-MM
    if (!month) return;
    const [y, m] = month.split('-').map(n => parseInt(n, 10));
    startDate = `${month}-01`;
    const lastDay = new Date(y, m, 0).getDate();
    endDate = `${month}-${String(lastDay).padStart(2,'0')}`;
  } else {
    startDate = document.getElementById('compareStart').value;
    endDate = document.getElementById('compareEnd').value;
  }

  try {
    const { data: schedules } = await supabaseClient
      .from('employee_schedules')
      .select('*')
      .gte('schedule_date', startDate)
      .lte('schedule_date', endDate);

    const { data: logs } = await supabaseClient
      .from('task_time_logs')
      .select(`
        *,
        kitchen_prep_employees(name)
      `)
      .gte('date', startDate)
      .lte('date', endDate);

    // Totals per employee
    const scheduleTotals = {};
    (schedules || []).forEach(s => {
      const mins = calculateHours(s.start_time, s.end_time);
      scheduleTotals[s.employee_name] = (scheduleTotals[s.employee_name] || 0) + mins;
    });

    const workedTotals = {};
    (logs || []).forEach(l => {
      if (!l.end_time) return;
      const emp = l.kitchen_prep_employees?.name || 'Unknown';
      const mins = (new Date(l.end_time) - new Date(l.start_time)) / (1000 * 60);
      workedTotals[emp] = (workedTotals[emp] || 0) + mins;
    });

    const employees = Array.from(new Set([...Object.keys(scheduleTotals), ...Object.keys(workedTotals)])).sort();

    let html = '<table class="schedule-table"><thead><tr><th>Employee</th><th>Scheduled</th><th>Worked</th><th>Variance</th></tr></thead><tbody>';

    employees.forEach(emp => {
      const sch = scheduleTotals[emp] || 0;
      const wrk = workedTotals[emp] || 0;
      const variance = sch - wrk;
      html += `
        <tr>
          <td><strong>${emp}</strong></td>
          <td>${formatTime(sch)}</td>
          <td>${formatTime(wrk)}</td>
          <td><span class="badge ${Math.abs(variance) > 60 ? 'danger' : 'warning'}">${formatTime(variance)}</span></td>
        </tr>
      `;
    });

    html += '</tbody></table>';
    document.getElementById('comparisonList').innerHTML = html;
  } catch (error) {
    console.error('Error loading comparison:', error);
  }
}

// ========== GAP ANALYSIS ==========
function changeGapPeriod() {
  const period = document.getElementById('gapPeriod').value;
  document.getElementById('gapDailyGroup').style.display = period === 'daily' ? 'block' : 'none';
  document.getElementById('gapWeeklyGroup').style.display = period === 'weekly' ? 'block' : 'none';
  document.getElementById('gapMonthlyGroup').style.display = period === 'monthly' ? 'block' : 'none';
  document.getElementById('gapCustomGroup').style.display = period === 'custom' ? 'block' : 'none';
  document.getElementById('gapCustomGroup2').style.display = period === 'custom' ? 'block' : 'none';
}

// ‚úÖ FIXED GAP ANALYSIS - ONLY COUNTS GAPS WITHIN SCHEDULED HOURS
async function loadGapAnalysis() {
  const period = document.getElementById('gapPeriod').value;
  let startDate, endDate;

  if (period === 'daily') {
    startDate = document.getElementById('gapDate').value;
    endDate = startDate;
  } else if (period === 'weekly') {
    startDate = document.getElementById('gapWeek').value;
    const weekEnd = new Date(startDate);
    weekEnd.setDate(weekEnd.getDate() + 6);
    endDate = weekEnd.toISOString().split('T')[0];
  } else if (period === 'monthly') {
    const month = document.getElementById('gapMonth').value; // YYYY-MM
    if (!month) return;
    const [y, m] = month.split('-').map(n => parseInt(n, 10));
    startDate = `${month}-01`;
    const lastDay = new Date(y, m, 0).getDate();
    endDate = `${month}-${String(lastDay).padStart(2,'0')}`;
  } else {
    startDate = document.getElementById('gapStart').value;
    endDate = document.getElementById('gapEnd').value;
  }

  try {
    // ‚úÖ STEP 1: Get employee schedules for this period (to know shift times)
    const { data: schedules } = await supabaseClient
      .from('employee_schedules')
      .select('employee_name, schedule_date, start_time, end_time')
      .gte('schedule_date', startDate)
      .lte('schedule_date', endDate);

    // Build schedule map: employee_name + date ‚Üí {start, end}
    const scheduleMap = new Map();
    (schedules || []).forEach(schedule => {
      const key = `${schedule.employee_name}|${schedule.schedule_date}`;
      scheduleMap.set(key, {
        start: schedule.start_time,
        end: schedule.end_time
      });
    });

    // ‚úÖ STEP 2: Get task logs
    const { data: logs } = await supabaseClient
      .from('task_time_logs')
      .select(`
        *,
        kitchen_prep_employees(name),
        kitchen_tasks(name)
      `)
      .gte('date', startDate)
      .lte('date', endDate)
      .order('start_time', { ascending: true });

    const gaps = [];
    const employeeLastEnd = {};

    logs?.forEach(log => {
      if (!log.end_time) return;

      const emp = log.kitchen_prep_employees?.name;
      const logDate = log.date || log.start_time.split('T')[0];

      // ‚úÖ STEP 3: Get employee's scheduled shift for this date
      const scheduleKey = `${emp}|${logDate}`;
      const schedule = scheduleMap.get(scheduleKey);

      if (!schedule) {
        // No schedule found - use old logic (count all gaps)
        if (employeeLastEnd[emp]) {
          const gapMinutes = (new Date(log.start_time) - new Date(employeeLastEnd[emp])) / (1000 * 60);
          if (gapMinutes > 5) {
            gaps.push({
              employee: emp,
              gapStart: employeeLastEnd[emp],
              gapEnd: log.start_time,
              duration: gapMinutes,
              taskBefore: log.kitchen_tasks?.name,
              date: log.date,
              withinSchedule: false
            });
          }
        }
        employeeLastEnd[emp] = log.end_time;
        return;
      }

      // ‚úÖ STEP 4: Parse scheduled shift times
      const scheduledStart = new Date(`${logDate}T${schedule.start}`);
      const scheduledEnd = new Date(`${logDate}T${schedule.end}`);
      const taskStart = new Date(log.start_time);
      const taskEnd = new Date(log.end_time);

      // ‚úÖ STEP 5: Only count gaps WITHIN scheduled hours (between tasks only)
      if (employeeLastEnd[emp]) {
        const previousEnd = new Date(employeeLastEnd[emp]);
        const gapStart = previousEnd;
        const gapEnd = taskStart;

        // Calculate the overlap with scheduled hours
        const effectiveGapStart = gapStart < scheduledStart ? scheduledStart : gapStart;
        const effectiveGapEnd = gapEnd > scheduledEnd ? scheduledEnd : gapEnd;

        // Only count if gap is within scheduled hours
        if (effectiveGapStart < effectiveGapEnd) {
          const gapMinutes = (effectiveGapEnd - effectiveGapStart) / (1000 * 60);
          if (gapMinutes > 5) { // Only track gaps > 5 minutes
            gaps.push({
              employee: emp,
              gapStart: effectiveGapStart.toISOString(),
              gapEnd: effectiveGapEnd.toISOString(),
              duration: gapMinutes,
              taskBefore: log.kitchen_tasks?.name,
              date: log.date,
              withinSchedule: true,
              scheduledStart: schedule.start,
              scheduledEnd: schedule.end
            });
          }
        }
      }

      // ‚úÖ STEP 6: Update last end time (but don't count overtime as gap)
      // Only update if task ended within or at scheduled end
      if (taskEnd <= scheduledEnd) {
        employeeLastEnd[emp] = log.end_time;
      } else {
        // Task went into overtime - don't count time after scheduled end as gap
        employeeLastEnd[emp] = scheduledEnd.toISOString();
      }
    });

    // ‚úÖ STEP 7: Display results
    let html = '';
    if (gaps.length === 0) {
      html = '<p style="text-align: center; color: #718096; padding: 24px;">No significant gaps found (gaps > 5 minutes within scheduled hours)</p>';
    } else {
      html = '<table class="schedule-table"><thead><tr><th>Date</th><th>Employee</th><th>Gap Start</th><th>Gap End</th><th>Duration</th><th>Next Task</th><th>Shift</th></tr></thead><tbody>';
      gaps.forEach(gap => {
        html += `
          <tr style="${gap.withinSchedule ? '' : 'background: #fef3c7;'}">
            <td>${formatDate(gap.date)}</td>
            <td><strong>${gap.employee}</strong></td>
            <td>${new Date(gap.gapStart).toLocaleTimeString()}</td>
            <td>${new Date(gap.gapEnd).toLocaleTimeString()}</td>
            <td><span class="badge ${gap.duration > 30 ? 'danger' : 'warning'}">${formatTime(gap.duration)}</span></td>
            <td>${gap.taskBefore || 'N/A'}</td>
            <td>${gap.scheduledStart || 'N/A'} - ${gap.scheduledEnd || 'N/A'}</td>
          </tr>
        `;
      });
      html += '</tbody></table>';

      const totalGapMinutes = gaps.reduce((sum, g) => sum + g.duration, 0);
      const withinScheduleGaps = gaps.filter(g => g.withinSchedule).length;
      html += `<div class="gap-alert">‚ö†Ô∏è Total gap time: ${formatTime(totalGapMinutes)} across ${gaps.length} gaps (${withinScheduleGaps} within scheduled hours)</div>`;
    }

    document.getElementById('gapList').innerHTML = html;
  } catch (error) {
    console.error('Error loading gap analysis:', error);
  }
}
</script>
</body>
</html>
